#include "Cell.h"

Cell::Cell()
    : mOwner(NO_OWNER)
{

}

////////////////////////////////////////////////////////////////////////////////

char Cell::owner() const
{
    return mOwner;
}

////////////////////////////////////////////////////////////////////////////////

bool Cell::hasOwner() const
{
    return mOwner != NO_OWNER;
}

////////////////////////////////////////////////////////////////////////////////

void Cell::setOwner(char owner)
{
    mOwner = owner;
}

////////////////////////////////////////////////////////////////////////////////

void Cell::addBorder(const BorderLine& border)
{
    mBorders.insert(border);
}

////////////////////////////////////////////////////////////////////////////////

void Cell::removerBorder(const BorderLine& border)
{
    mBorders.erase(border);
}

////////////////////////////////////////////////////////////////////////////////

bool Cell::hasBorder(const BorderLine& border) const
{
    return mBorders.find(border) != mBorders.end();
}

////////////////////////////////////////////////////////////////////////////////

std::unordered_set<BorderLine>::const_iterator Cell::beginBorders() const
{
    return mBorders.begin();
}

////////////////////////////////////////////////////////////////////////////////

std::unordered_set<BorderLine>::const_iterator Cell::endBorders() const
{
    return mBorders.end();
}

////////////////////////////////////////////////////////////////////////////////

bool Cell::operator==(const Cell& other) const
{
    if (other.mOwner != mOwner)
        return false;
    
    const auto oEnd = other.mBorders.end();
    for (auto itr = mBorders.begin(), max = mBorders.end(); itr != max; ++itr)
        if (other.mBorders.find(*itr) == oEnd)
            return false;
        
    return true;
}

////////////////////////////////////////////////////////////////////////////////

bool Cell::operator!=(const Cell& other) const
{
    return !operator==(other);
}